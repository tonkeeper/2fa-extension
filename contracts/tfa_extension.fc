#include "imports/stdlib.fc";
#include "imports/shared.fc";

const op::install =              0x43563174;
const op::send_actions =         0xb15f2c8c;
const op::add_device_key =       0x0a73fcb4;
const op::remove_device_key =    0xa04d2666;
const op::fast_recover_access =  0x59c538dd;
const op::slow_recover_access =  0xd0029d00;
const op::cancel_fast_recovery = 0x30f0a407;
const op::remove_extension =     0x9d8084d6;
const op::delegation =           0x23d9c15c;
const op::cancel_delegation =    0xde82b501;

const config::FAST_RECOVERY_TIMEOUT = 60 * 60 * 24;
const config::DELEGATION_TIMEOUT = 60 * 60 * 24 * 14;
const config::SLOW_RECOVERY_TIMEOUT = 60 * 60 * 24 * 14;
const config::RETRAY_TIMEOUT = 60 * 60 * 24;

const recover_state::none = 0;
const recover_state::fast = 1;
const recover_state::slow = 2;
const recover_state::delegation = 3;

const err::extension_already_installed = 160;
const err::sender_is_not_owner = 161;
const err::wrong_service_signature = 162;
const err::wrong_device_signature = 163;
const err::wrong_seed_signature = 164;
const err::wrong_seqno = 165;
const err::expired = 166;
const err::recovery_in_progress = 167;
const err::device_key_exists = 168;
const err::device_key_not_found = 169;
const err::action_timeout = 170;
const err::mismatched_data = 171;
const err::wrong_state = 172;
const err::no_recovery_initiated = 173;
const err::no_delegation_initiated = 174;

const INSTALL_PLUGIN_GAS_USAGE = 4128;

(int, slice, int, int, cell, int, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(32),
        ds~load_msg_addr(),
        ds~load_uint(256),
        ds~load_uint(256),
        ds~load_dict(),
        ds~load_uint(2),
        ds
    );
}

;; Initialize starting values properly.
;; Note: If the last 32 bits are used to mine the contract address,
;;       they will not be stored in the state.
() save_state_after_install(
    slice wallet,
    int service_pubkey,
    int seed_pubkey,
    cell device_pubkeys
) impure inline {
    set_data(
        begin_cell()
            .store_uint(1, 32)
            .store_slice(wallet)
            .store_uint(service_pubkey, 256)
            .store_uint(seed_pubkey, 256)
            .store_dict(device_pubkeys)
            .store_uint(0, 2)
            .store_uint(0, 64)
            .end_cell()
    );
}

() save_state(
    int seqno,
    slice wallet,
    int service_pubkey,
    int seed_pubkey,
    cell device_pubkeys,
    int state_,
    slice state
) impure inline {
    set_data(
        begin_cell()
            .store_uint(seqno, 32)
            .store_slice(wallet)
            .store_uint(service_pubkey, 256)
            .store_uint(seed_pubkey, 256)
            .store_dict(device_pubkeys)
            .store_uint(state_, 2)
            .store_slice(state)
            .end_cell()
    );
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (slice_empty?(in_msg_body)) {
        ;; refill
        return ();
    }

    var cs = in_msg_full.begin_parse();
    cs~load_uint(4); ;; skip flags
    slice sender = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int state,
        slice rest_state
    ) = load_data();

    if (op == op::install) {
        throw_unless(err::extension_already_installed, seqno == 0);
        throw_unless(err::sender_is_not_owner, equal_slices(sender, wallet_addr));

        int new_service_pubkey = in_msg_body~load_uint(256);
        int new_seed_pubkey = in_msg_body~load_uint(256);
        cell new_device_pubkeys = in_msg_body~load_dict();

        save_state_after_install(
            sender,
            new_service_pubkey,
            new_seed_pubkey,
            new_device_pubkeys
        );

        (int wc, int _hash) = parse_std_addr(my_address());

        cell msg = begin_cell()
            .store_nonbounce_flags()
            .store_slice(wallet_addr)
            .store_coins(get_compute_fee(wc, INSTALL_PLUGIN_GAS_USAGE) * 3)
            .store_ref_body(
                begin_cell()
                .store_uint(op::wallet::request_by_extension, 32)
                .store_uint(0, 64)
                .store_out_action_list(null())
                .store_int(-1, 1)
                .store_set_signature_auth(
                    0,
                    null()
                )
                .end_cell()
            )
            .end_cell();

        send_raw_message(msg, PAY_FEE_SEPARATELY);

        return ();
    }

    throw(0xffff);
}

(slice, ()) check_2fa(slice cs, slice service_signature, int service_pubkey, cell device_pubkeys, int stored_seqno) impure inline {
    slice device_info = cs~load_ref().begin_parse();
    slice device_signature = device_info~load_bits(512);
    int device_pubkey_id = device_info~load_uint(32);
    device_info.end_parse();

    int root_hash = slice_hash(cs);

    (slice device_pubkey_slice, int found?) = device_pubkeys.udict_get?(32, device_pubkey_id);
    int device_pubkey = device_pubkey_slice.preload_uint(256);
    throw_unless(
        err::wrong_device_signature,
        check_signature(root_hash, device_signature, device_pubkey)
    );

    throw_unless(
        err::wrong_service_signature,
        check_signature(root_hash, service_signature, service_pubkey)
    );

    cs~skip_bits(32);
    int seqno = cs~load_uint(32);
    int valid_until = cs~load_uint(64);

    throw_unless(err::wrong_seqno, seqno == stored_seqno);
    throw_unless(err::expired, valid_until >= now());

    return (cs, ());
}

(slice, ()) check_2fa_with_seed(slice cs, slice service_signature, int service_pubkey, int seed_pubkey, int stored_seqno) impure {
    slice seed_info = cs~load_ref().begin_parse();
    slice seed_signature = seed_info~load_bits(512);
    seed_info.end_parse();

    int root_hash = slice_hash(cs);

    throw_unless(
        err::wrong_service_signature,
        check_signature(root_hash, service_signature, service_pubkey)
    );
    throw_unless(
        err::wrong_seed_signature,
        check_signature(root_hash, seed_signature, seed_pubkey)
    );

    cs~skip_bits(32);

    int seqno = cs~load_uint(32);
    throw_unless(err::wrong_seqno, seqno == stored_seqno);

    int valid_until = cs~load_uint(64);
    throw_unless(err::expired, valid_until >= now());

    return (cs, ());
}

(slice, ()) check_seed_auth(slice cs, slice seed_signature, int seed_pubkey, int stored_seqno) impure inline {
    int root_hash = slice_hash(cs);

    throw_unless(err::wrong_seed_signature, check_signature(root_hash, seed_signature, seed_pubkey));

    cs~skip_bits(32);

    int seqno = cs~load_uint(32);
    throw_unless(err::wrong_seqno, seqno == stored_seqno);

    int valid_until = cs~load_uint(64);
    throw_unless(err::expired, valid_until >= now());

    return (cs, ());
}

() recv_external(slice in_msg) impure {
    slice signature1 = in_msg~load_bits(512);
    int op = in_msg.preload_uint(32);

    var ds = get_data().begin_parse();

    int seqno = ds~load_uint(32);
    slice immutable_tail = ds;

    slice wallet_addr = ds~load_msg_addr();
    int service_pubkey = ds~load_uint(256);
    int seed_pubkey = ds~load_uint(256);
    cell device_pubkeys = ds~load_dict();
    int state = ds~load_uint(2);
    slice rest_state = ds;

    if (op == op::send_actions) {
        throw_if(err::recovery_in_progress, state);
        in_msg~check_2fa(signature1, service_pubkey, device_pubkeys, seqno);
        accept_message();

        set_data(
            begin_cell()
                .store_uint(seqno + 1, 32)
                .store_slice(immutable_tail)
                .end_cell()
        );
        commit();

        int mode = in_msg~load_uint(8);
        cell msg = in_msg.preload_ref();

        send_raw_message(msg, mode);

        return ();
    }

    if (op == op::add_device_key) {
        throw_if(err::recovery_in_progress, state);
        in_msg~check_2fa(signature1, service_pubkey, device_pubkeys, seqno);

        int new_device_pubkey_id = in_msg~load_uint(32);
        slice new_device_pubkey = in_msg~load_ref().begin_parse();

        (cell new_device_pubkeys, int added?) = device_pubkeys.udict_add?(32, new_device_pubkey_id, new_device_pubkey);

        throw_unless(err::device_key_exists, added?);

        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            new_device_pubkeys,
            recover_state::none,
            rest_state
        );

        return ();
    }

    if (op == op::remove_device_key) {
        throw_if(err::recovery_in_progress, state);
        in_msg~check_2fa(signature1, service_pubkey, device_pubkeys, seqno);

        int device_pubkey_id = in_msg~load_uint(32);
        (cell new_device_pubkeys, int deleted?) = device_pubkeys.udict_delete?(32, device_pubkey_id);

        throw_unless(err::device_key_not_found, deleted?);

        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            new_device_pubkeys,
            recover_state::none,
            rest_state
        );

        return ();
    }

    if (op == op::fast_recover_access) {
        in_msg~check_2fa_with_seed(signature1, service_pubkey, seed_pubkey, seqno);

        int recovery_blocked_until = rest_state~load_uint(64);

        if (state == recover_state::none) {
            ;; Fast recover should be initiated even if other recovery is in progress.
            ;; Other recovery will be canceled.
            ;; This is done to prevent the situation when the hacker will initiate other recovery
            ;; and the user will not have time to cancel it.
            int new_device_pubkey = in_msg~load_uint(256);
            int new_device_pubkey_id = in_msg~load_uint(32);

            accept_message();

            slice new_recovery_state = begin_cell()
                .store_uint(now() + config::FAST_RECOVERY_TIMEOUT, 64) ;; recovery_blocked_until
                .store_ref(
                    begin_cell()
                        .store_uint(new_device_pubkey, 256) ;; new_device_pubkey
                        .store_uint(new_device_pubkey_id, 32) ;; new_device_pubkey_id
                        .end_cell()
                )
                .end_cell()
                .begin_parse();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                recover_state::fast,
                new_recovery_state
            );
        } elseif (state == recover_state::fast) {
            throw_unless(err::action_timeout, recovery_blocked_until <= now());

            slice added_info = rest_state~load_ref().begin_parse();

            slice new_device_pubkey = added_info~load_bits(256);
            int new_device_pubkey_id = added_info~load_uint(32);

            throw_unless(err::mismatched_data, equal_slices(new_device_pubkey, in_msg~load_bits(256)));
            throw_unless(err::mismatched_data, new_device_pubkey_id == in_msg~load_uint(32));

            accept_message();

            cell new_device_pubkeys = null();
            new_device_pubkeys = new_device_pubkeys.udict_set(32, new_device_pubkey_id, new_device_pubkey);

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                new_device_pubkeys,
                recover_state::none,
                begin_cell().store_uint(0, 64).end_cell().begin_parse()
            );
        } else {
            throw(err::wrong_state);
        }

        return ();
    }

    if (op == op::slow_recover_access) {
        in_msg~check_seed_auth(signature1, seed_pubkey, seqno);

        int recovery_blocked_until = rest_state~load_uint(64);
        throw_unless(err::action_timeout, recovery_blocked_until <= now());

        if (state == recover_state::none) {
            int new_device_pubkey = in_msg~load_uint(256);
            int new_device_pubkey_id = in_msg~load_uint(32);

            accept_message();

            slice new_recovery_state = begin_cell()
                .store_uint(now() + config::SLOW_RECOVERY_TIMEOUT, 64) ;; recovery_blocked_until
                .store_ref(
                    begin_cell()
                        .store_uint(new_device_pubkey, 256) ;; new_device_pubkey
                        .store_uint(new_device_pubkey_id, 32) ;; new_device_pubkey_id
                        .end_cell()
                )
                .end_cell()
                .begin_parse();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                recover_state::slow,
                new_recovery_state
            );
        } elseif (state == recover_state::slow) {
            slice added_info = rest_state~load_ref().begin_parse();

            slice new_device_pubkey = added_info~load_bits(256);
            int new_device_pubkey_id = added_info~load_uint(32);

            throw_unless(err::mismatched_data, equal_slices(new_device_pubkey, in_msg~load_bits(256)));
            throw_unless(err::mismatched_data, new_device_pubkey_id == in_msg~load_uint(32));

            accept_message();

            cell new_device_pubkeys = null();
            new_device_pubkeys = new_device_pubkeys.udict_set(32, new_device_pubkey_id, new_device_pubkey);

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                new_device_pubkeys,
                recover_state::none,
                begin_cell().store_uint(0, 64).end_cell().begin_parse()
            );
        } else {
            throw(err::wrong_state);
        }

        return ();
    }

    if (op == op::cancel_fast_recovery) {
        in_msg~check_2fa_with_seed(signature1, service_pubkey, seed_pubkey, seqno);

        throw_unless(err::no_recovery_initiated, state == recover_state::fast);
        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            device_pubkeys,
            recover_state::none,
            begin_cell().store_uint(now() + config::RETRAY_TIMEOUT, 64).end_cell().begin_parse()
        );

        return ();
    }

    if (op == op::remove_extension) {
        in_msg~check_2fa(signature1, service_pubkey, device_pubkeys, seqno);

        throw_unless(err::recovery_in_progress, state == recover_state::none);
        accept_message();

        var msg = begin_cell()
            .store_nonbounce_flags()
            .store_slice(wallet_addr)
            .store_coins(0)
            .store_ref_body(
                begin_cell()
                    .store_uint(op::wallet::request_by_extension, 32)
                    .store_uint(0, 64)
                    .store_out_action_list(null())
                    .store_int(-1, 1)
                    .store_set_signature_auth(
                        1,
                        begin_cell()
                        .store_delete_ext_action(
                            my_address(),
                            null()
                        ).end_cell()
                    )
                    .end_cell()
            );

        send_raw_message(msg.end_cell(), CARRY_CONTRACT_BALANCE + DESTROY_IF_BALANCE_ZERO);
        return ();
    }

    if (op == op::delegation) {
        in_msg~check_seed_auth(signature1, seed_pubkey, seqno);

        int recovery_blocked_until = rest_state~load_uint(64);
        throw_unless(err::action_timeout, recovery_blocked_until <= now());

        if (state == recover_state::none) {
            cell new_state_init = in_msg~load_ref();
            int forward_amount = in_msg~load_coins();

            accept_message();

            slice new_recovery_state = begin_cell()
                .store_uint(now() + config::DELEGATION_TIMEOUT, 64) ;; recovery_blocked_until
                .store_ref(new_state_init)
                .store_coins(forward_amount)
                .end_cell()
                .begin_parse();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                recover_state::delegation,
                new_recovery_state
            );
        } elseif (state == recover_state::delegation) {
            cell new_state_init = rest_state~load_ref();
            int forward_amount = rest_state~load_coins();

            throw_unless(err::mismatched_data, cell_hash(new_state_init) == cell_hash(in_msg~load_ref()));
            throw_unless(err::mismatched_data, forward_amount == in_msg~load_coins());

            accept_message();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                recover_state::none,
                begin_cell().store_uint(0, 64).end_cell().begin_parse()
            );

            slice new_extension_address = calculate_address(0, new_state_init);

            var msg = begin_cell()
                .store_nonbounce_flags()
                .store_slice(wallet_addr)
                .store_coins(0)
                .store_ref_body(
                    begin_cell()
                    .store_uint(op::wallet::request_by_extension, 32)
                    .store_uint(0, 64)
                    .store_out_action_list(
                        new_out_action_send_msg(
                            begin_cell().end_cell(),
                            0,
                            begin_cell()
                                .store_nonbounce_flags()
                                .store_slice(new_extension_address)
                                .store_coins(forward_amount)
                                .store_uint(4 + 2, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
                                .store_ref(new_state_init)
                                .end_cell()
                        )
                    )
                    .store_uint(1, 1)
                    .store_add_ext_action_continue(
                        new_extension_address,
                        begin_cell().store_delete_ext_action_end(my_address()).end_cell()
                    )
                    .end_cell()
                );

            send_raw_message(msg.end_cell(), CARRY_CONTRACT_BALANCE + DESTROY_IF_BALANCE_ZERO);
        } else {
            throw(err::wrong_state);
        }
    }

    if (op == op::cancel_delegation) {
        in_msg~check_seed_auth(signature1, seed_pubkey, seqno);

        throw_unless(err::no_delegation_initiated, (state == recover_state::delegation) | (state == recover_state::slow));
        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            device_pubkeys,
            recover_state::none,
            begin_cell().store_uint(now() + config::RETRAY_TIMEOUT, 64).end_cell().begin_parse()
        );

        return ();
    }
}

;; GET METHODS

int get_seqno() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return seqno;
}

slice get_wallet_addr() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return wallet_addr;
}

int get_service_pubkey() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return service_pubkey;
}

int get_seed_pubkey() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return seed_pubkey;
}

cell get_device_pubkeys() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return device_pubkeys;
}

int get_device_pubkey(int device_pubkey_id) method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    (slice device_pubkey, int found?) = device_pubkeys.udict_get?(32, device_pubkey_id);
    return device_pubkey.preload_uint(256);
}

forall X -> tuple to_tuple(X x) asm "NOP";

(int, int, tuple) get_recover_state() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();

    int recovery_blocked_until = rest_state~load_uint(64);

    if (recover_state == recover_state::none) {
        return (recover_state, recovery_blocked_until, to_tuple([]));
    } elseif ((recover_state == recover_state::fast) | (recover_state == recover_state::slow)) {
        slice added_info = rest_state~load_ref().begin_parse();

        int new_device_pubkey = added_info~load_uint(256);
        int new_device_pubkey_id = added_info~load_uint(32);

        return (recover_state, recovery_blocked_until, to_tuple([new_device_pubkey_id, new_device_pubkey]));
    } elseif (recover_state == recover_state::delegation) {
        cell new_state_init = rest_state~load_ref();
        int forward_amount = rest_state~load_coins();

        return (recover_state, recovery_blocked_until, to_tuple([new_state_init, forward_amount]));
    } else {
        throw(0xffff);
        return (0, 0, to_tuple([]));
    }
}

const int GAS_WALLET_PROCESS_BASE = 3545;
const int GAS_WALLET_PROCESS_PER_ACTION = 717;
const int GAS_WALLET_PROCESS_PER_ACTION_EXT = 2000;

int get_gas_fee_for_processing_send_actions(
    cell forward_msg,
    int msg_actions,
    int extended_actions
) method_id {
    int compute_fee = get_compute_fee(
        0,
            ;; there can be more than 1 extension in the wallet and that can increase the cost
            ;; of processing the message
            (GAS_WALLET_PROCESS_BASE * 3)
            + GAS_WALLET_PROCESS_PER_ACTION * msg_actions
            + GAS_WALLET_PROCESS_PER_ACTION_EXT * extended_actions
    );
    (int cells, int bits, int z, int w) = compute_data_size?(forward_msg, 10000);
    int fwd_fees = get_forward_fee(0, bits, cells);
    return compute_fee + fwd_fees;
}