#include "imports/stdlib.fc";
#include "imports/shared.fc";

const op::install = 125;
const op::send_actions = 130;
const op::authorize_device = 131;
const op::unauthorize_device = 132;
const op::recover_access = 133;
const op::cancel_request = 134;
const op::destruct = 135;
const op::disable = 136;
const op::cancel_disabling = 137;

const one_ton = 1000000000;

(int, slice, int, int, cell, int, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_uint(32),
        ds~load_msg_addr(),
        ds~load_uint(256),
        ds~load_uint(256),
        ds~load_dict(),
        ds~load_uint(2),
        ds
    );
}

() save_state(
    int seqno,
    slice wallet,
    int service_pubkey,
    int seed_pubkey,
    cell device_pubkeys,
    int state_,
    slice state
) impure inline {
    set_data(
        begin_cell()
            .store_uint(seqno, 32)
            .store_slice(wallet)
            .store_uint(service_pubkey, 256)
            .store_uint(seed_pubkey, 256)
            .store_dict(device_pubkeys)
            .store_uint(state_, 2)
            .store_slice(state)
            .end_cell()
    );
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (slice_empty?(in_msg_body)) {
        ;; refill
        return ();
    }

    var cs = in_msg_full.begin_parse();
    cs~load_uint(4); ;; skip flags
    slice sender = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int state,
        slice rest_state
    ) = load_data();

    if (op == op::install) {
        throw_unless(35, seqno == 0);
        throw_unless(36, equal_slices(sender, wallet_addr));

        int new_service_pubkey = in_msg_body~load_uint(256);
        int new_seed_pubkey = in_msg_body~load_uint(256);
        cell new_device_pubkeys = in_msg_body~load_dict();

        save_state(
            1,
            sender,
            new_service_pubkey,
            new_seed_pubkey,
            new_device_pubkeys,
            state,
            rest_state
        );

        cell msg = begin_cell()
            .store_nonbounce_flags()
            .store_slice(wallet_addr)
            .store_coins(one_ton / 100)
            .store_ref_body(
                begin_cell()
                .store_uint(op::wallet::request_by_extension, 32)
                .store_uint(0, 64)
                .store_out_action_list(null())
                .store_int(-1, 1)
                .store_set_signature_auth(
                    0,
                    null()
                )
                .end_cell()
            )
            .end_cell();

        send_raw_message(msg, 0);

        return ();
    }

    throw(0xffff);
}

(slice, ()) check_2fa(slice cs, int service_pubkey, cell device_pubkeys, int stored_seqno) impure inline {
    slice service_signature = cs~load_bits(512);

    slice device_info = cs~load_ref().begin_parse();
    slice device_signature = device_info~load_bits(512);
    int device_pubkey_id = device_info.preload_uint(32);

    int root_hash = slice_hash(cs);

    (slice device_pubkey_slice, int found?) = device_pubkeys.udict_get?(32, device_pubkey_id);
    int device_pubkey = device_pubkey_slice.preload_uint(256);
    throw_unless(
        33,
        check_signature(root_hash, device_signature, device_pubkey)
    );

    throw_unless(32, check_signature(root_hash, service_signature, service_pubkey));

    int seqno = cs~load_uint(32);
    int valid_until = cs~load_uint(64);

    throw_unless(34, seqno == stored_seqno);
    throw_unless(38, valid_until >= now());

    return (cs, ());
}

(slice, ()) check_2fa_with_seed(slice cs, int service_pubkey, int seed_pubkey, int stored_seqno) impure {
    slice service_signature = cs~load_bits(512);

    slice seed_info = cs~load_ref().begin_parse();
    slice seed_signature = seed_info~load_bits(512);

    int root_hash = slice_hash(cs);

    throw_unless(35, check_signature(root_hash, service_signature, service_pubkey));
    throw_unless(36, check_signature(root_hash, seed_signature, seed_pubkey));

    int seqno = cs~load_uint(32);
    throw_unless(37, seqno == stored_seqno);

    int valid_until = cs~load_uint(64);
    throw_unless(38, valid_until >= now());

    return (cs, ());
}

(slice, ()) check_seed_auth(slice cs, int seed_pubkey, int stored_seqno) impure inline {
    slice seed_signature = cs~load_bits(512);
    int root_hash = slice_hash(cs);

    throw_unless(35, check_signature(root_hash, seed_signature, seed_pubkey));

    int seqno = cs~load_uint(32);
    throw_unless(37, seqno == stored_seqno);

    int valid_until = cs~load_uint(64);
    throw_unless(38, valid_until >= now());

    return (cs, ());
}

() recv_external(slice in_msg) impure {
    int op = in_msg~load_uint(32);

    var ds = get_data().begin_parse();

    int seqno = ds~load_uint(32);
    slice immutable_tail = ds;

    slice wallet_addr = ds~load_msg_addr();
    int service_pubkey = ds~load_uint(256);
    int seed_pubkey = ds~load_uint(256);
    cell device_pubkeys = ds~load_dict();
    int state = ds~load_uint(2);
    slice rest_state = ds;

    if (op == op::send_actions) {
        throw_if(38, state);
        in_msg~check_2fa(service_pubkey, device_pubkeys, seqno);
        accept_message();

        set_data(
            begin_cell()
                .store_uint(seqno + 1, 32)
                .store_slice(immutable_tail)
                .end_cell()
        );
        commit();

        cell body = in_msg.preload_ref();

        cell msg = begin_cell()
            .store_nonbounce_flags()
            .store_slice(wallet_addr)
            .store_coins(0)
            .store_ref_body(body)
            .end_cell();

        send_raw_message(msg, 128);

        return ();
    }

    if (op == op::authorize_device) {
        throw_if(38, state);
        in_msg~check_2fa(service_pubkey, device_pubkeys, seqno);

        int new_device_pubkey_id = in_msg~load_uint(32);
        slice new_device_pubkey = in_msg~load_ref().begin_parse();

        (cell new_device_pubkeys, int added?) = device_pubkeys.udict_add?(32, new_device_pubkey_id, new_device_pubkey);

        throw_unless(34, added?);

        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            new_device_pubkeys,
            0,
            rest_state
        );

        return ();
    }

    if (op == op::unauthorize_device) {
        throw_if(38, state);
        in_msg~check_2fa(service_pubkey, device_pubkeys, seqno);

        int device_pubkey_id = in_msg~load_uint(32);
        (cell new_device_pubkeys, int deleted?) = device_pubkeys.udict_delete?(32, device_pubkey_id);

        throw_unless(34, deleted?);

        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            new_device_pubkeys,
            0,
            rest_state
        );

        return ();
    }

    if (op == op::recover_access) {
        in_msg~check_2fa_with_seed(service_pubkey, seed_pubkey, seqno);

        int recovery_blocked_until = rest_state~load_uint(64);
        throw_unless(33, recovery_blocked_until <= now());

        if (state == 0) {
            accept_message();

            int new_device_pubkey = in_msg~load_uint(256);
            int new_device_pubkey_id = in_msg~load_uint(32);

            slice new_recovery_state = begin_cell()
                .store_uint(now() + 60 * 60 * 24 * 3, 64) ;; recovery_blocked_until
                .store_ref(
                    begin_cell()
                        .store_uint(new_device_pubkey, 256) ;; new_device_pubkey
                        .store_uint(new_device_pubkey_id, 32) ;; new_device_pubkey_id
                        .end_cell()
                )
                .end_cell()
                .begin_parse();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                1,
                new_recovery_state
            );
        } elseif (state == 1) {
            slice added_info = rest_state~load_ref().begin_parse();

            slice new_device_pubkey = added_info~load_bits(256);
            int new_device_pubkey_id = added_info~load_uint(32);

            throw_unless(35, equal_slices(new_device_pubkey, in_msg~load_bits(256)));
            throw_unless(36, new_device_pubkey_id == in_msg~load_uint(32));

            accept_message();

            cell new_device_pubkeys = null();
            new_device_pubkeys = new_device_pubkeys.udict_set(32, new_device_pubkey_id, new_device_pubkey);

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                new_device_pubkeys,
                0,
                begin_cell().store_uint(now() + 60 * 60, 64).end_cell().begin_parse()
            );
        } else {
            throw(39);
        }

        return ();
    }

    if (op == op::cancel_request) {
        in_msg~check_2fa_with_seed(service_pubkey, seed_pubkey, seqno);

        throw_unless(32, state == 1);
        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            device_pubkeys,
            0,
            begin_cell().store_uint(now() + 60 * 60, 64).end_cell().begin_parse()
        );

        return ();
    }

    if (op == op::destruct) {
        in_msg~check_2fa(service_pubkey, device_pubkeys, seqno);

        throw_unless(32, state == 0);
        accept_message();

        var msg = begin_cell()
            .store_nonbounce_flags()
            .store_slice(wallet_addr)
            .store_coins(0)
            .store_ref_body(
                begin_cell()
                    .store_uint(op::wallet::request_by_extension, 32)
                    .store_uint(0, 64)
                    .store_out_action_list(null())
                    .store_int(-1, 1)
                    .store_set_signature_auth(
                        1,
                        begin_cell()
                        .store_delete_ext_action(
                            my_address(),
                            null()
                        ).end_cell()
                    )
                    .end_cell()
            );


        send_raw_message(msg.end_cell(), CARRY_CONTRACT_BALANCE + DESTROY_IF_BALANCE_ZERO);
        return ();
    }

    if (op == op::disable) {
        in_msg~check_seed_auth(seed_pubkey, seqno);

        int recovery_blocked_until = rest_state~load_uint(64);
        throw_unless(33, recovery_blocked_until <= now());

        if (state == 0) {
            accept_message();

            cell new_state_init = in_msg~load_ref();
            int forward_amount = in_msg~load_coins();

            slice new_recovery_state = begin_cell()
                .store_uint(now() + 60 * 60 * 24 * 3, 64) ;; recovery_blocked_until
                .store_ref(new_state_init)
                .store_coins(forward_amount)
                .end_cell()
                .begin_parse();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                2,
                new_recovery_state
            );
        } elseif (state == 2) {
            cell new_state_init = rest_state~load_ref();
            int forward_amount = rest_state~load_coins();

            throw_unless(35, cell_hash(new_state_init) == cell_hash(in_msg~load_ref()));
            throw_unless(36, forward_amount == in_msg~load_coins());

            accept_message();

            save_state(
                seqno + 1,
                wallet_addr,
                service_pubkey,
                seed_pubkey,
                device_pubkeys,
                0,
                begin_cell().store_uint(now() + 60 * 60, 64).end_cell().begin_parse()
            );

            slice new_extension_address = calculate_address(0, new_state_init);

            var msg = begin_cell()
                .store_nonbounce_flags()
                .store_slice(wallet_addr)
                .store_coins(0)
                .store_ref_body(
                    begin_cell()
                    .store_uint(op::wallet::request_by_extension, 32)
                    .store_uint(0, 64)
                    .store_out_action_list(
                        new_out_action_send_msg(
                            begin_cell().end_cell(),
                            0,
                            begin_cell()
                                .store_nonbounce_flags()
                                .store_slice(new_extension_address)
                                .store_coins(forward_amount)
                                .store_uint(4 + 2, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
                                .store_ref(new_state_init)
                                .end_cell()
                        )
                    )
                    .store_uint(1, 1)
                    .store_add_ext_action_continue(
                        new_extension_address,
                        begin_cell().store_delete_ext_action_end(my_address()).end_cell()
                    )
                    .end_cell()
                );


            send_raw_message(msg.end_cell(), CARRY_CONTRACT_BALANCE + DESTROY_IF_BALANCE_ZERO);
        } else {
            throw(39);
        }
    }

    if (op == op::cancel_disabling) {
        in_msg~check_seed_auth(seed_pubkey, seqno);

        throw_unless(32, state == 2);
        accept_message();

        save_state(
            seqno + 1,
            wallet_addr,
            service_pubkey,
            seed_pubkey,
            device_pubkeys,
            0,
            begin_cell().store_uint(now() + 60 * 60, 64).end_cell().begin_parse()
        );

        return ();
    }
}

;; GET METHODS

int get_seqno() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return seqno;
}

slice get_wallet_addr() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return wallet_addr;
}

int get_service_pubkey() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return service_pubkey;
}

int get_seed_pubkey() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return seed_pubkey;
}

cell get_device_pubkeys() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    return device_pubkeys;
}

int get_device_pubkey(int device_pubkey_id) method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    (slice device_pubkey, int found?) = device_pubkeys.udict_get?(32, device_pubkey_id);
    return device_pubkey.preload_uint(256);
}

(int, int, int, int) get_recover_state() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    int recovery_blocked_until = rest_state~load_uint(64);

    if (recover_state == 1) {
        slice added_info = rest_state~load_ref().begin_parse();

        int new_device_pubkey = added_info~load_uint(256);
        int new_device_pubkey_id = added_info~load_uint(32);

        return (1, recovery_blocked_until, new_device_pubkey_id, new_device_pubkey);
    } else {
        return (recover_state, recovery_blocked_until, 0, 0);
    }
}

(int, int, cell, int) get_disable_state() method_id {
    (
        int seqno,
        slice wallet_addr,
        int service_pubkey,
        int seed_pubkey,
        cell device_pubkeys,
        int recover_state,
        slice rest_state
    ) = load_data();
    int recovery_blocked_until = rest_state~load_uint(64);

    if (recover_state == 2) {
        cell new_state_init = rest_state~load_ref();
        int forward_amount = rest_state~load_coins();

        return (2, recovery_blocked_until, new_state_init, forward_amount);
    } else {
        return (recover_state, recovery_blocked_until, null(), 0);
    }
}